// <auto-generated />
//
// To parse this JSON data, add NuGet 'Newtonsoft.Json' then do:
//
//    using QuickType;
//
//    var variables = Variables.FromJson(jsonString);

namespace StockPrice.SiteMethods.USA_Sites.SearsPartsDirectResponseQuickType
{
    using System;
    using System.Collections.Generic;

    using System.Globalization;
    using Newtonsoft.Json;
    using Newtonsoft.Json.Converters;

    public partial class Variables
    {
        [JsonProperty("data")]
        public Data Data { get; set; }
    }

    public partial class Data
    {
        [JsonProperty("partSearch")]
        public PartSearch PartSearch { get; set; }
    }

    public partial class PartSearch
    {
        [JsonProperty("totalCount")]
        public long TotalCount { get; set; }

        [JsonProperty("parts")]
        public Part[] Parts { get; set; }

        [JsonProperty("taxonomyFilter")]
        public TaxonomyFilter[] TaxonomyFilter { get; set; }

        [JsonProperty("availabilityFilter")]
        public object AvailabilityFilter { get; set; }

        [JsonProperty("__typename")]
        public PartSearchTypename Typename { get; set; }
    }

    public partial class SubstitutedByList
    {
        [JsonProperty("parts")]
        public Part[] Parts { get; set; }

        [JsonProperty("__typename")]
        public PartSearchTypename Typename { get; set; }
    }

    public partial class Part
    {
        [JsonProperty("id")]
        public string Id { get; set; }

        [JsonProperty("number")]
        public string Number { get; set; }

        [JsonProperty("title")]
        public string Title { get; set; }

        [JsonProperty("topSoldPosition")]
        public long TopSoldPosition { get; set; }

        [JsonProperty("media")]
        public Media Media { get; set; }

        [JsonProperty("subscribable")]
        public bool Subscribable { get; set; }

        [JsonProperty("subscriptions")]
        public object[] Subscriptions { get; set; }

        [JsonProperty("taxonomies")]
        public Taxonomies Taxonomies { get; set; }

        [JsonProperty("division")]
        public Division Division { get; set; }

        [JsonProperty("sourceId")]
        [JsonConverter(typeof(ParseStringConverter))]
        public long SourceId { get; set; }

        [JsonProperty("restrictions")]
        public Restriction[] Restrictions { get; set; }

        [JsonProperty("pricing")]
        public Pricing Pricing { get; set; }

        [JsonProperty("substitutedByList", NullValueHandling = NullValueHandling.Ignore)]
        public SubstitutedByList SubstitutedByList { get; set; }

        [JsonProperty("__typename")]
        public PartTypename Typename { get; set; }
    }

    public partial class Division
    {
        [JsonProperty("id")]
        public string Id { get; set; }

        [JsonProperty("description")]
        public Description Description { get; set; }

        [JsonProperty("__typename")]
        public DivisionTypename Typename { get; set; }
    }

    public partial class Media
    {
        [JsonProperty("image")]
        public Image Image { get; set; }

        [JsonProperty("__typename")]
        public MediaTypename Typename { get; set; }
    }

    public partial class Image
    {
        [JsonProperty("urls")]
        public Uri[] Urls { get; set; }

        [JsonProperty("__typename")]
        public ImageTypename Typename { get; set; }
    }

    public partial class Pricing
    {
        [JsonProperty("strikeThroughPriceType")]
        public StrikeThroughPriceType StrikeThroughPriceType { get; set; }

        [JsonProperty("sell")]
        public double Sell { get; set; }

        [JsonProperty("list")]
        public double List { get; set; }

        [JsonProperty("availabilityInfo")]
        public AvailabilityInfo AvailabilityInfo { get; set; }

        [JsonProperty("__typename")]
        public PricingTypename Typename { get; set; }
    }

    public partial class AvailabilityInfo
    {
        [JsonProperty("status")]
        public Status Status { get; set; }

        [JsonProperty("inventory")]
        public long Inventory { get; set; }

        [JsonProperty("__typename")]
        public AvailabilityInfoTypename Typename { get; set; }
    }

    public partial class Restriction
    {
        [JsonProperty("id")]
        [JsonConverter(typeof(ParseStringConverter))]
        public long Id { get; set; }

        [JsonProperty("type")]
        public string Type { get; set; }

        [JsonProperty("channelId")]
        public string ChannelId { get; set; }

        [JsonProperty("allStates")]
        public bool AllStates { get; set; }

        [JsonProperty("states")]
        public string[] States { get; set; }

        [JsonProperty("__typename")]
        public string Typename { get; set; }
    }

    public partial class DescDetails
    {
        [JsonProperty("id")]
        [JsonConverter(typeof(ParseStringConverter))]
        public long Id { get; set; }

        [JsonProperty("name")]
        public string Name { get; set; }

        [JsonProperty("parents", NullValueHandling = NullValueHandling.Ignore)]
        public Taxonomies Parents { get; set; }

        [JsonProperty("__typename")]
        public DescDetailsTypename Typename { get; set; }

        [JsonProperty("level", NullValueHandling = NullValueHandling.Ignore)]
        public long? Level { get; set; }
    }

    public partial class Taxonomies
    {
        [JsonProperty("taxonomies")]
        public DescDetails[] TaxonomiesTaxonomies { get; set; }

        [JsonProperty("__typename")]
        public TaxonomiesTypename Typename { get; set; }
    }

    public partial class TaxonomyFilter
    {
        [JsonProperty("descDetails")]
        public DescDetails DescDetails { get; set; }

        [JsonProperty("__typename")]
        public TaxonomyFilterTypename Typename { get; set; }
    }

    public enum PartSearchTypename { PartResultOutput };

    public enum Description { LaundryAppliances };

    public enum DivisionTypename { Division };

    public enum ImageTypename { Media };

    public enum MediaTypename { MediaResult };

    public enum Status { Nla, Pia };

    public enum AvailabilityInfoTypename { PartAvailability };

    public enum StrikeThroughPriceType { Msrp, None, Phone };

    public enum PricingTypename { PartPricing };

    public enum DescDetailsTypename { Taxonomy };

    public enum TaxonomiesTypename { TaxonomyResultOutput };

    public enum PartTypename { Part };

    public enum TaxonomyFilterTypename { FilterItemOutput };

    public partial class Variables
    {
        public static Variables FromJson(string json) => JsonConvert.DeserializeObject<Variables>(json, StockPrice.SiteMethods.USA_Sites.SearsPartsDirectResponseQuickType.Converter.Settings);
    }

    public static class Serialize
    {
        public static string ToJson(this Variables self) => JsonConvert.SerializeObject(self, StockPrice.SiteMethods.USA_Sites.SearsPartsDirectResponseQuickType.Converter.Settings);
    }

    internal static class Converter
    {
        public static readonly JsonSerializerSettings Settings = new JsonSerializerSettings
        {
            MetadataPropertyHandling = MetadataPropertyHandling.Ignore,
            DateParseHandling = DateParseHandling.None,
            Converters =
            {
                PartSearchTypenameConverter.Singleton,
                PartTypenameConverter.Singleton,
                DivisionTypenameConverter.Singleton,
                DescriptionConverter.Singleton,
                MediaTypenameConverter.Singleton,
                ImageTypenameConverter.Singleton,
                PricingTypenameConverter.Singleton,
                AvailabilityInfoTypenameConverter.Singleton,
                StatusConverter.Singleton,
                StrikeThroughPriceTypeConverter.Singleton,
                TaxonomiesTypenameConverter.Singleton,
                DescDetailsTypenameConverter.Singleton,
                TaxonomyFilterTypenameConverter.Singleton,
                new IsoDateTimeConverter { DateTimeStyles = DateTimeStyles.AssumeUniversal }
            },
        };
    }

    internal class PartSearchTypenameConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(PartSearchTypename) || t == typeof(PartSearchTypename?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            if (value == "PartResultOutput")
            {
                return PartSearchTypename.PartResultOutput;
            }
            throw new Exception("Cannot unmarshal type PartSearchTypename");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (PartSearchTypename)untypedValue;
            if (value == PartSearchTypename.PartResultOutput)
            {
                serializer.Serialize(writer, "PartResultOutput");
                return;
            }
            throw new Exception("Cannot marshal type PartSearchTypename");
        }

        public static readonly PartSearchTypenameConverter Singleton = new PartSearchTypenameConverter();
    }

    internal class PartTypenameConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(PartTypename) || t == typeof(PartTypename?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            if (value == "Part")
            {
                return PartTypename.Part;
            }
            throw new Exception("Cannot unmarshal type PartTypename");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (PartTypename)untypedValue;
            if (value == PartTypename.Part)
            {
                serializer.Serialize(writer, "Part");
                return;
            }
            throw new Exception("Cannot marshal type PartTypename");
        }

        public static readonly PartTypenameConverter Singleton = new PartTypenameConverter();
    }

    internal class DivisionTypenameConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(DivisionTypename) || t == typeof(DivisionTypename?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            if (value == "Division")
            {
                return DivisionTypename.Division;
            }
            throw new Exception("Cannot unmarshal type DivisionTypename");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (DivisionTypename)untypedValue;
            if (value == DivisionTypename.Division)
            {
                serializer.Serialize(writer, "Division");
                return;
            }
            throw new Exception("Cannot marshal type DivisionTypename");
        }

        public static readonly DivisionTypenameConverter Singleton = new DivisionTypenameConverter();
    }

    internal class DescriptionConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(Description) || t == typeof(Description?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            if (value == "Laundry Appliances")
            {
                return Description.LaundryAppliances;
            }
            throw new Exception("Cannot unmarshal type Description");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (Description)untypedValue;
            if (value == Description.LaundryAppliances)
            {
                serializer.Serialize(writer, "Laundry Appliances");
                return;
            }
            throw new Exception("Cannot marshal type Description");
        }

        public static readonly DescriptionConverter Singleton = new DescriptionConverter();
    }

    internal class MediaTypenameConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(MediaTypename) || t == typeof(MediaTypename?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            if (value == "MediaResult")
            {
                return MediaTypename.MediaResult;
            }
            throw new Exception("Cannot unmarshal type MediaTypename");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (MediaTypename)untypedValue;
            if (value == MediaTypename.MediaResult)
            {
                serializer.Serialize(writer, "MediaResult");
                return;
            }
            throw new Exception("Cannot marshal type MediaTypename");
        }

        public static readonly MediaTypenameConverter Singleton = new MediaTypenameConverter();
    }

    internal class ImageTypenameConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(ImageTypename) || t == typeof(ImageTypename?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            if (value == "Media")
            {
                return ImageTypename.Media;
            }
            throw new Exception("Cannot unmarshal type ImageTypename");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (ImageTypename)untypedValue;
            if (value == ImageTypename.Media)
            {
                serializer.Serialize(writer, "Media");
                return;
            }
            throw new Exception("Cannot marshal type ImageTypename");
        }

        public static readonly ImageTypenameConverter Singleton = new ImageTypenameConverter();
    }

    internal class PricingTypenameConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(PricingTypename) || t == typeof(PricingTypename?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            if (value == "PartPricing")
            {
                return PricingTypename.PartPricing;
            }
            throw new Exception("Cannot unmarshal type PricingTypename");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (PricingTypename)untypedValue;
            if (value == PricingTypename.PartPricing)
            {
                serializer.Serialize(writer, "PartPricing");
                return;
            }
            throw new Exception("Cannot marshal type PricingTypename");
        }

        public static readonly PricingTypenameConverter Singleton = new PricingTypenameConverter();
    }

    internal class AvailabilityInfoTypenameConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(AvailabilityInfoTypename) || t == typeof(AvailabilityInfoTypename?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            if (value == "PartAvailability")
            {
                return AvailabilityInfoTypename.PartAvailability;
            }
            throw new Exception("Cannot unmarshal type AvailabilityInfoTypename");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (AvailabilityInfoTypename)untypedValue;
            if (value == AvailabilityInfoTypename.PartAvailability)
            {
                serializer.Serialize(writer, "PartAvailability");
                return;
            }
            throw new Exception("Cannot marshal type AvailabilityInfoTypename");
        }

        public static readonly AvailabilityInfoTypenameConverter Singleton = new AvailabilityInfoTypenameConverter();
    }

    internal class StatusConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(Status) || t == typeof(Status?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "NLA":
                    return Status.Nla;
                case "PIA":
                    return Status.Pia;
            }
            throw new Exception("Cannot unmarshal type Status");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (Status)untypedValue;
            switch (value)
            {
                case Status.Nla:
                    serializer.Serialize(writer, "NLA");
                    return;
                case Status.Pia:
                    serializer.Serialize(writer, "PIA");
                    return;
            }
            throw new Exception("Cannot marshal type Status");
        }

        public static readonly StatusConverter Singleton = new StatusConverter();
    }

    internal class StrikeThroughPriceTypeConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(StrikeThroughPriceType) || t == typeof(StrikeThroughPriceType?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "MSRP":
                    return StrikeThroughPriceType.Msrp;
                case "NONE":
                    return StrikeThroughPriceType.None;
                case "PHONE":
                    return StrikeThroughPriceType.Phone;
            }
            throw new Exception("Cannot unmarshal type StrikeThroughPriceType");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (StrikeThroughPriceType)untypedValue;
            switch (value)
            {
                case StrikeThroughPriceType.Msrp:
                    serializer.Serialize(writer, "MSRP");
                    return;
                case StrikeThroughPriceType.None:
                    serializer.Serialize(writer, "NONE");
                    return;
                case StrikeThroughPriceType.Phone:
                    serializer.Serialize(writer, "PHONE");
                    return;
            }
            throw new Exception("Cannot marshal type StrikeThroughPriceType");
        }

        public static readonly StrikeThroughPriceTypeConverter Singleton = new StrikeThroughPriceTypeConverter();
    }

    internal class ParseStringConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(long) || t == typeof(long?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            long l;
            if (Int64.TryParse(value, out l))
            {
                return l;
            }
            throw new Exception("Cannot unmarshal type long");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (long)untypedValue;
            serializer.Serialize(writer, value.ToString());
            return;
        }

        public static readonly ParseStringConverter Singleton = new ParseStringConverter();
    }

    internal class TaxonomiesTypenameConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(TaxonomiesTypename) || t == typeof(TaxonomiesTypename?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            if (value == "TaxonomyResultOutput")
            {
                return TaxonomiesTypename.TaxonomyResultOutput;
            }
            throw new Exception("Cannot unmarshal type TaxonomiesTypename");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (TaxonomiesTypename)untypedValue;
            if (value == TaxonomiesTypename.TaxonomyResultOutput)
            {
                serializer.Serialize(writer, "TaxonomyResultOutput");
                return;
            }
            throw new Exception("Cannot marshal type TaxonomiesTypename");
        }

        public static readonly TaxonomiesTypenameConverter Singleton = new TaxonomiesTypenameConverter();
    }

    internal class DescDetailsTypenameConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(DescDetailsTypename) || t == typeof(DescDetailsTypename?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            if (value == "Taxonomy")
            {
                return DescDetailsTypename.Taxonomy;
            }
            throw new Exception("Cannot unmarshal type DescDetailsTypename");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (DescDetailsTypename)untypedValue;
            if (value == DescDetailsTypename.Taxonomy)
            {
                serializer.Serialize(writer, "Taxonomy");
                return;
            }
            throw new Exception("Cannot marshal type DescDetailsTypename");
        }

        public static readonly DescDetailsTypenameConverter Singleton = new DescDetailsTypenameConverter();
    }

    internal class TaxonomyFilterTypenameConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(TaxonomyFilterTypename) || t == typeof(TaxonomyFilterTypename?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            if (value == "FilterItemOutput")
            {
                return TaxonomyFilterTypename.FilterItemOutput;
            }
            throw new Exception("Cannot unmarshal type TaxonomyFilterTypename");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (TaxonomyFilterTypename)untypedValue;
            if (value == TaxonomyFilterTypename.FilterItemOutput)
            {
                serializer.Serialize(writer, "FilterItemOutput");
                return;
            }
            throw new Exception("Cannot marshal type TaxonomyFilterTypename");
        }

        public static readonly TaxonomyFilterTypenameConverter Singleton = new TaxonomyFilterTypenameConverter();
    }
}
